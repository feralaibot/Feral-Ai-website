<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Feral PNG Randomizer (Web)</title>
  <style>
    :root { color-scheme: light; font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; background: #0f172a; color: #e2e8f0; }
    body { margin: 0; padding: 32px; display: flex; justify-content: center; }
    .wrap { width: min(960px, 100%); background: #0b1223; border: 1px solid #1e293b; border-radius: 14px; padding: 28px 32px; box-shadow: 0 20px 70px rgba(0,0,0,0.35); }
    h1 { margin: 0 0 12px; letter-spacing: -0.02em; }
    p.lead { margin: 0 0 20px; color: #94a3b8; }
    label { display: block; margin-top: 14px; font-weight: 600; }
    input, textarea, button { width: 100%; box-sizing: border-box; margin-top: 8px; padding: 10px 12px; border-radius: 10px; border: 1px solid #1e293b; background: #0f172a; color: #e2e8f0; }
    textarea { min-height: 160px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    input[type="file"] { padding: 6px 0; }
    .row { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; }
    button { cursor: pointer; background: linear-gradient(120deg, #d946ef, #8b5cf6); border: none; font-weight: 700; letter-spacing: 0.01em; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    .status { margin-top: 14px; color: #38bdf8; font-weight: 600; }
    .small { color: #94a3b8; font-size: 13px; margin-top: 4px; }
    .inline { display: flex; align-items: center; gap: 10px; }
    .inline input[type="checkbox"] { width: auto; margin-top: 0; }

    /* Preview + weights */
    .preview { margin-top: 24px; padding: 16px; border: 1px solid #1e293b; border-radius: 12px; background: #0f172a; }
    .preview h3 { margin: 0 0 6px; }
    .layers { display: grid; gap: 12px; }
    .layer-card { border: 1px solid #1e293b; border-radius: 10px; padding: 12px; background: #0b1223; }
    .layer-head { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
    .assets { width: 100%; border-collapse: collapse; margin-top: 10px; }
    .assets th, .assets td { padding: 6px; text-align: left; font-size: 14px; }
    .assets th { color: #cbd5e1; }
    .assets td { color: #e2e8f0; }
    .weight-inputs { display: flex; gap: 8px; align-items: center; }
    .weight-inputs input[type="range"] { flex: 1; }
    .thumb { width: 64px; height: 64px; object-fit: cover; border-radius: 8px; border: 1px solid #1e293b; }
    .flex-row { display: flex; gap: 12px; align-items: center; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Feral PNG Randomizer</h1>
    <p class="lead">Upload your layers zip, set supply, and download ready-to-mint images + metadata.</p>
    <form id="genForm">
      <label>Layers Zip (.zip containing layer folders with PNGs)
        <input type="file" id="layers" accept=".zip">
      </label>
      <label>Layers Folder (select the root folder that contains ordered subfolders)
        <input type="file" id="folder" webkitdirectory directory>
        <div class="small">Keeps your subfolder structure intact; we will zip it client-side for you.</div>
      </label>
      <div class="row">
        <div>
          <label>Canvas Width
            <input type="number" id="width" value="1024" min="1" required>
          </label>
        </div>
        <div>
          <label>Canvas Height
            <input type="number" id="height" value="1024" min="1" required>
          </label>
        </div>
        <div>
          <label>Supply
            <input type="number" id="supply" value="100" min="1" required>
          </label>
        </div>
      </div>
      <div class="row">
        <div>
          <label>Name Prefix
            <input type="text" id="namePrefix" value="FERAL">
          </label>
        </div>
        <div>
          <label>Symbol
            <input type="text" id="symbol" value="FERAL">
          </label>
        </div>
        <div>
          <label>Wallet Address
            <input type="text" id="walletAddress" placeholder="Your payout address">
          </label>
        </div>
      </div>
      <label class="inline">
        <input type="checkbox" id="unique" checked>
        Enforce uniqueness (skip duplicates)
      </label>
      <label>Rules JSON (optional, { block: [], force: [] })
        <textarea id="rules">{ "block": [], "force": [] }</textarea>
        <div class="small">Same block/force structure as the desktop app.</div>
      </label>
      <label>API URL
        <input type="text" id="apiUrl" value="https://feral-ai-website.onrender.com/generate">
        <div class="small">Defaults to the hosted API. Change only if you run your own endpoint.</div>
      </label>
      <button type="submit" id="submit">Generate</button>
      <div class="status" id="status"></div>
    </form>
    <div class="preview" id="preview" style="display:none;">
      <h3>Layers & Rarity</h3>
      <div class="small" id="previewHint">Loaded layers will appear here.</div>
      <div class="layers" id="layerList"></div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    const statusEl = document.getElementById("status");
    const submitBtn = document.getElementById("submit");
    const folderInput = document.getElementById("folder");
    const zipInput = document.getElementById("layers");
    const previewEl = document.getElementById("preview");
    const layerListEl = document.getElementById("layerList");
    const previewHintEl = document.getElementById("previewHint");

    let currentLayers = {}; // { layerName: [{ name, path, file?, getBlob }] }

    function layerSortKey(name) {
      const match = /^\s*(\d+)/.exec(name);
      if (match) return [parseInt(match[1], 10), name];
      return [Number.MAX_SAFE_INTEGER, name];
    }

    function setStatus(msg, isError = false) {
      statusEl.textContent = msg;
      statusEl.style.color = isError ? "#fda4af" : "#38bdf8";
    }

    function stripRoot(path) {
      const parts = (path || "").split(/\\/g).join("/").split("/");
      return parts.length > 1 ? parts.slice(1).join("/") : parts[0];
    }

    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = "";
      const chunk = 0x8000;
      for (let i = 0; i < bytes.length; i += chunk) {
        binary += String.fromCharCode(...bytes.subarray(i, i + chunk));
      }
      return btoa(binary);
    }

    function resetPreview() {
      currentLayers = {};
      layerListEl.innerHTML = "";
      previewEl.style.display = "none";
    }

    function updatePercents(layerCard) {
      const rows = layerCard.querySelectorAll('[data-role="asset-row"]');
      let total = 0;
      rows.forEach(row => {
        const weight = parseFloat(row.querySelector('[data-role="weight-number"]').value) || 0;
        total += weight;
      });
      rows.forEach(row => {
        const weight = parseFloat(row.querySelector('[data-role="weight-number"]').value) || 0;
        const pctEl = row.querySelector('[data-role="percent"]');
        const pct = total > 0 ? (weight / total) * 100 : 0;
        pctEl.textContent = `${pct.toFixed(1)}%`;
      });
    }

    function renderPreview() {
      layerListEl.innerHTML = "";
      const layerNames = Object.keys(currentLayers).sort((a, b) => {
        const ka = layerSortKey(a);
        const kb = layerSortKey(b);
        if (ka[0] !== kb[0]) return ka[0] - kb[0];
        return ka[1].localeCompare(kb[1]);
      });
      if (!layerNames.length) {
        previewEl.style.display = "none";
        return;
      }
      previewEl.style.display = "block";
      previewHintEl.textContent = `${layerNames.length} layer(s) loaded. Adjust weights to set rarity.`;

      layerNames.forEach(layer => {
        const card = document.createElement('div');
        card.className = 'layer-card';

        const header = document.createElement('div');
        header.className = 'layer-head';
        header.innerHTML = `<strong>${layer}</strong><span class="small">${currentLayers[layer].length} assets</span>`;
        card.appendChild(header);

        const table = document.createElement('table');
        table.className = 'assets';
        const thead = document.createElement('thead');
        thead.innerHTML = '<tr><th>Asset</th><th>Weight</th><th>Expected</th></tr>';
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        currentLayers[layer].forEach((asset, idx) => {
          const tr = document.createElement('tr');
          tr.setAttribute('data-role', 'asset-row');

          const nameTd = document.createElement('td');
          const rowWrap = document.createElement('div');
          rowWrap.className = 'flex-row';
          if (asset.thumbUrl) {
            const img = document.createElement('img');
            img.className = 'thumb';
            img.src = asset.thumbUrl;
            img.alt = asset.name;
            rowWrap.appendChild(img);
          }
          const label = document.createElement('div');
          label.innerHTML = `<div>${asset.name}</div><div class="small">${asset.path}</div>`;
          rowWrap.appendChild(label);
          nameTd.appendChild(rowWrap);

          const weightTd = document.createElement('td');
          const inputs = document.createElement('div');
          inputs.className = 'weight-inputs';
          const range = document.createElement('input');
          range.type = 'range';
          range.min = '0';
          range.max = '100';
          range.step = '0.1';
          range.value = '1';
          range.setAttribute('data-role', 'weight-range');
          const num = document.createElement('input');
          num.type = 'number';
          num.min = '0';
          num.step = '0.1';
          num.value = '1';
          num.style.width = '90px';
          num.setAttribute('data-role', 'weight-number');
          inputs.appendChild(range);
          inputs.appendChild(num);
          weightTd.appendChild(inputs);

          const pctTd = document.createElement('td');
          const pctSpan = document.createElement('span');
          pctSpan.setAttribute('data-role', 'percent');
          pctSpan.textContent = '—';
          pctTd.appendChild(pctSpan);

          tr.appendChild(nameTd);
          tr.appendChild(weightTd);
          tr.appendChild(pctTd);
          tbody.appendChild(tr);

          range.addEventListener('input', () => { num.value = range.value; updatePercents(card); });
          num.addEventListener('input', () => { range.value = num.value; updatePercents(card); });
        });

        table.appendChild(tbody);
        card.appendChild(table);
        layerListEl.appendChild(card);
        updatePercents(card);
      });
    }

    async function loadFolderPreview(fileList) {
      resetPreview();
      const files = Array.from(fileList);
      const imageFiles = files.filter(f => /\.(png|jpg|jpeg|webp)$/i.test(f.name));
      imageFiles.sort((a, b) => (a.webkitRelativePath || a.name).localeCompare(b.webkitRelativePath || b.name));
      const layersMap = {};
      for (const file of imageFiles) {
        const path = stripRoot(file.webkitRelativePath || file.name);
        const parts = path.split('/');
        if (parts.length < 2) continue; // need layer/asset
        const layer = parts[0];
        const assetName = parts.slice(1).join('/');
        layersMap[layer] = layersMap[layer] || [];
        layersMap[layer].push({ name: assetName, path, file });
      }

      // assign thumb urls (first asset per layer)
      for (const layer of Object.keys(layersMap)) {
        layersMap[layer].sort((a, b) => a.path.localeCompare(b.path));
        let thumbSet = false;
        layersMap[layer].forEach(asset => {
          if (!thumbSet && asset.file) {
            asset.thumbUrl = URL.createObjectURL(asset.file);
            thumbSet = true;
          }
        });
      }
      currentLayers = layersMap;
      renderPreview();
    }

    async function loadZipPreview(file) {
      resetPreview();
      const buffer = await file.arrayBuffer();
      const zip = new JSZip();
      const loaded = await zip.loadAsync(buffer);
      const layersMap = {};
      const entries = Object.values(loaded.files).filter(e => !e.dir && /\.(png|jpg|jpeg|webp)$/i.test(e.name));
      entries.sort((a, b) => a.name.localeCompare(b.name));

      for (const entry of entries) {
        const path = stripRoot(entry.name);
        const parts = path.split('/');
        if (parts.length < 2) continue;
        const layer = parts[0];
        const assetName = parts.slice(1).join('/');
        layersMap[layer] = layersMap[layer] || [];
        layersMap[layer].push({ name: assetName, path, entry });
      }

      // set thumb for first asset per layer
      for (const layer of Object.keys(layersMap)) {
        layersMap[layer].sort((a, b) => a.path.localeCompare(b.path));
        const first = layersMap[layer][0];
        if (first && first.entry) {
          const blob = await first.entry.async('blob');
          const url = URL.createObjectURL(blob);
          layersMap[layer].forEach((asset, idx) => {
            if (idx === 0) asset.thumbUrl = url;
          });
        }
      }
      currentLayers = layersMap;
      renderPreview();
    }

    folderInput.addEventListener('change', async (e) => {
      if (e.target.files && e.target.files.length) {
        await loadFolderPreview(e.target.files);
      } else {
        resetPreview();
      }
    });

    zipInput.addEventListener('change', async (e) => {
      if (e.target.files && e.target.files.length) {
        await loadZipPreview(e.target.files[0]);
      } else {
        resetPreview();
      }
    });

    async function buildZipFromFolder(fileList) {
      const zip = new JSZip();
      const files = Array.from(fileList).sort((a, b) => (a.webkitRelativePath || a.name).localeCompare(b.webkitRelativePath || b.name));
      for (const file of files) {
        const buf = await file.arrayBuffer();
        const path = stripRoot(file.webkitRelativePath || file.name);
        zip.file(path, buf);
      }
      const base64 = await zip.generateAsync({ type: "base64" });
      return base64;
    }

    document.getElementById("genForm").addEventListener("submit", async (e) => {
      e.preventDefault();
      const folderFiles = folderInput.files && folderInput.files.length ? folderInput.files : null;
      const zipFile = zipInput.files && zipInput.files.length ? zipInput.files[0] : null;
      if (!folderFiles && !zipFile) { setStatus("Please select a folder or a zip with layers.", true); return; }
      submitBtn.disabled = true;
      try {
        let layersZipBase64 = "";

        if (folderFiles) {
          setStatus("Zipping folder and preserving order…");
          layersZipBase64 = await buildZipFromFolder(folderFiles);
        } else if (zipFile) {
          setStatus("Reading layers zip…");
          const buffer = await zipFile.arrayBuffer();
          layersZipBase64 = arrayBufferToBase64(buffer);
        }

        let parsedRules = { block: [], force: [] };
        const rulesText = document.getElementById("rules").value.trim();
        if (rulesText) parsedRules = JSON.parse(rulesText);

        // Collect weights from UI
        const weights = {};
        layerListEl.querySelectorAll('.layer-card').forEach(card => {
          const layerName = card.querySelector('.layer-head strong')?.textContent || '';
          if (!layerName) return;
          weights[layerName] = {};
          card.querySelectorAll('[data-role="asset-row"]').forEach(row => {
            const label = row.querySelector('div > div');
            const assetName = label ? label.textContent.trim() : '';
            const weightVal = parseFloat(row.querySelector('[data-role="weight-number"]').value) || 0;
            if (assetName) weights[layerName][assetName] = weightVal;
          });
        });

        const payload = {
          layersZipBase64,
          supply: Number(document.getElementById("supply").value || 0),
          width: Number(document.getElementById("width").value || 0),
          height: Number(document.getElementById("height").value || 0),
          namePrefix: document.getElementById("namePrefix").value || "FERAL",
          symbol: document.getElementById("symbol").value || "FERAL",
          walletAddress: document.getElementById("walletAddress").value || "YOUR_WALLET",
          unique: document.getElementById("unique").checked,
          rules: parsedRules,
          weights
        };

        const apiUrl = document.getElementById("apiUrl").value || "/generate";
        setStatus("Generating on server…");
        const resp = await fetch(apiUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) {
          const err = await resp.json().catch(() => ({}));
          throw new Error(err.error || `HTTP ${resp.status}`);
        }
        const blob = await resp.blob();
        const minted = resp.headers.get("x-minted");
        setStatus(`Done. Minted ${minted || "?"}. Downloading…`);
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "feral-nfts.zip";
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 30000);
        setStatus("Download started.");
      } catch (err) {
        console.error(err);
        setStatus(err.message || "Failed to generate.", true);
      } finally {
        submitBtn.disabled = false;
      }
    });
  </script>
</body>
</html>
